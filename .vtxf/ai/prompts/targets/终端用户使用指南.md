# mcps-proxy - 终端用户使用指南

## 简介

mcps-proxy 是一个极简的MCP（Model Context Protocol）服务器代理工具，将多个独立的MCP服务器合并成一个统一的HTTP接口。

## 安装

### 全局安装
```bash
npm install -g mcps-proxy
```

### 本地安装
```bash
npm install mcps-proxy
```

### 验证安装
```bash
mcps-proxy --version
```

## 快速开始

### 1. 配置文件

mcps-proxy 使用配置文件 `~/.mcps-proxy/config.json` 来管理MCP服务器。首次运行时会自动创建默认配置。

### 2. 启动服务

```bash
# 启动服务（所有schema同时激活）
mcps-proxy

# 指定端口启动
mcps-proxy --port 8080

# 使用自定义配置文件
mcps-proxy --config ./my-config.json
```

启动后，服务将在指定端口（默认3095）运行，你可以通过HTTP API来访问MCP服务器的功能。

服务运行时会在控制台显示访问地址：
```
mcps-proxy is running on: http://localhost:3095
Press Ctrl+C to stop
```

### 3. 停止服务

按 `Ctrl+C` 停止服务。

## 配置文件

### 默认配置文件位置
配置文件位于：`~/.mcps-proxy/config.json`

### 配置文件结构

配置文件支持多个schemas，结构如下：

```json
{
  "server": {
    "port": 3095,
    "host": "0.0.0.0"
  },
  "schemas": {
    "default": {
      "mcpServers": {
        "zhipu-web-search": {
          "type": "http",
          "url": "https://open.bigmodel.cn/api/mcp/web_search_prime/mcp",
          "headers": {
            "Authorization": "Bearer ${Z_AI_API_KEY}"
          }
        },
        "filesystem": {
          "command": "npx",
          "args": [
            "@modelcontextprotocol/server-filesystem",
            "."
          ]
        },
        "git": {
          "command": "npx",
          "args": [
            "@modelcontextprotocol/server-git",
            "--repository",
            "."
          ]
        }
      }
    },
    "custom1": {
      "mcpServers": {
        "filesystem": {
          "command": "npx",
          "args": [
            "@modelcontextprotocol/server-filesystem",
            "./dev"
          ]
        },
        "fetch": {
          "command": "uvx",
          "args": [
            "mcp-server-fetch"
          ]
        },
        "sse-server": {
          "type": "sse",
          "url": "http://localhost:8080/sse",
          "headers": {
            "Authorization": "Bearer ${SSE_TOKEN}"
          }
        }
      }
    },
    "custom2": {
      "mcpServers": {
        "database": {
          "type": "http",
          "url": "http://localhost:5432/mcp",
          "headers": {
            "X-API-Key": "${DB_API_KEY}"
          }
        },
        "browser-automation": {
          "type": "sse",
          "url": "http://localhost:9222/sse",
          "reconnectInterval": 5000,
          "maxRetries": 3
        },
        "local-tools": {
          "command": "python",
          "args": [
            "-m",
            "custom_mcp_server"
          ],
          "env": {
            "PYTHONPATH": "/path/to/custom/modules"
          }
        }
      }
    }
  }
}
```

### Schema工作原理

所有schema会在启动时同时加载和激活，无需选择。每个schema提供独立的MCP服务器连接和工具集。

例如：
- `default` schema: 提供基础工具集
- `custom1` schema: 提供自定义工具集1
- `custom2` schema: 提供自定义工具集2

所有schema的工具都可以通过对应的API路径同时访问。

### Schema启用控制

每个schema可以包含`enabled`属性来控制是否启用该schema：

```json
{
  "schemas": {
    "default": {
      "enabled": true,
      "mcpServers": {
        "filesystem": {
          "command": "npx",
          "args": ["@modelcontextprotocol/server-filesystem", "."]
        }
      }
    },
    "development": {
      "enabled": false,
      "mcpServers": {
        "debug-tools": {
          "command": "node",
          "args": ["debug-server.js"]
        }
      }
    }
  }
}
```

**enabled属性说明**：
- `true`: 启用该schema（默认值，如果不指定则默认为true）
- `false`: 禁用该schema，所有对该schema的API请求将返回错误

当尝试访问已禁用的schema时，系统会返回如下错误响应：
```json
{
  "error": {
    "code": 404,
    "message": "Schema 'development' is disabled"
  }
}
```

### 编辑配置文件

你可以直接编辑配置文件来添加、修改或删除MCP服务器：

```bash
# 直接编辑配置文件
nano ~/.mcps-proxy/config.json

# 或使用其他编辑器
vim ~/.mcps-proxy/config.json
```

## HTTP API使用

启动服务后，可以通过统一的MCP协议端点访问所有MCP功能：

### 工具命名规则
所有工具都采用"服务器ID-工具名"的统一命名格式：
- 例如：`filesystem-read_file`、`git-commit`、`zhipu-web-search-webSearchPrime`
- 这样可以清楚识别每个工具的来源服务器
- 确保工具名称的唯一性和一致性

### API端点
```bash
# 统一MCP协议端点（支持所有MCP功能）
POST /api/{schema}/mcp

# 服务器状态查询
GET /api/status
```

**注意**: `{schema}` 是配置文件中定义的schema名称，如 `default`、`custom1`、`custom2` 等。状态查询接口不需要schema，因为它是全局的。

### MCP协议调用方法

#### 获取工具列表
```bash
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/list",
    "params": {},
    "id": 1
  }'
```

#### 调用工具
```bash
# 文件读取工具
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "filesystem-read_file",
      "arguments": {"path": "./package.json"}
    },
    "id": 2
  }'

# Web搜索工具
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "zhipu-web-search-webSearchPrime",
      "arguments": {"search_query": "MCP协议介绍"}
    },
    "id": 3
  }'

# Git提交工具
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "git-commit",
      "arguments": {"message": "更新文档", "files": ["."]}
    },
    "id": 4
  }'
```

#### 获取资源列表
```bash
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "resources/list",
    "params": {},
    "id": 5
  }'
```

#### 读取资源
```bash
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "resources/read",
    "params": {
      "uri": "file://./README.md"
    },
    "id": 6
  }'
```

#### 获取提示列表
```bash
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "prompts/list",
    "params": {},
    "id": 7
  }'
```

#### 获取提示内容
```bash
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "prompts/get",
    "params": {
      "name": "code-review",
      "arguments": {"language": "typescript"}
    },
    "id": 8
  }'
```

### 状态查询

```bash
# 获取完整状态信息
curl http://localhost:3095/api/status
```

状态响应示例：
```json
{
  "server": {
    "status": "running",
    "port": 3095,
    "url": "http://localhost:3095",
    "uptime": "00:05:23"
  },
  "schemas": {
    "default": {
      "status": "active",
      "mcpServers": [
        {
          "id": "filesystem",
          "name": "文件系统服务器",
          "status": "connected",
          "type": "stdio",
          "toolCount": 8
        },
        {
          "id": "git",
          "name": "Git工具",
          "status": "connected",
          "type": "stdio",
          "toolCount": 12
        }
      ],
      "totalTools": 20,
      "connectedServers": 2
    },
    "dev": {
      "status": "active",
      "mcpServers": [
        {
          "id": "filesystem",
          "name": "文件系统",
          "status": "connected",
          "type": "stdio",
          "toolCount": 5
        }
      ],
      "totalTools": 5,
      "connectedServers": 1
    },
    "production": {
      "status": "active",
      "mcpServers": [
        {
          "id": "database",
          "name": "数据库服务器",
          "status": "connected",
          "type": "http",
          "toolCount": 3
        }
      ],
      "totalTools": 3,
      "connectedServers": 1
    }
  },
  "summary": {
    "totalSchemas": 3,
    "activeSchemas": 3,
    "totalServers": 4,
    "connectedServers": 4,
    "failedServers": 0,
    "totalTools": 28
  }
}
```

## 实际使用场景

### Web前端使用示例

创建简单的JavaScript封装函数：

```javascript
// MCP客户端封装
class McpsProxyClient {
  constructor(baseUrl, schema = 'default') {
    this.baseUrl = baseUrl;
    this.schema = schema;
    this.id = 1;
  }

  async request(method, params = {}) {
    const response = await fetch(`${this.baseUrl}/api/${this.schema}/mcp`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: method,
        params: params,
        id: this.id++
      })
    });

    return response.json();
  }

  // 获取工具列表
  async getTools() {
    return this.request('tools/list');
  }

  // 调用工具
  async callTool(toolName, args) {
    return this.request('tools/call', {
      name: toolName,
      arguments: args
    });
  }

  // 获取资源列表
  async getResources() {
    return this.request('resources/list');
  }

  // 读取资源
  async readResource(uri) {
    return this.request('resources/read', { uri });
  }

  // 获取提示列表
  async getPrompts() {
    return this.request('prompts/list');
  }

  // 获取提示内容
  async getPrompt(promptName, args) {
    return this.request('prompts/get', {
      name: promptName,
      arguments: args
    });
  }
}

// 使用示例
const client = new McpsProxyClient('http://localhost:3095', 'default');

// 获取工具列表
client.getTools().then(result => {
  console.log('可用工具:', result.result.tools);
});

// 调用文件读取工具
client.callTool('filesystem-read_file', {path: './package.json'}).then(result => {
  console.log('文件内容:', result.result.content);
});
```

### 实际使用场景

#### 场景1：日常文件操作

```bash
# 1. 启动服务
mcps-proxy

# 2. 查看当前目录文件
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "filesystem-read_directory",
      "arguments": {"path": "."}
    },
    "id": 1
  }'

# 3. 读取文件内容
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "filesystem-read_file",
      "arguments": {"path": "./package.json"}
    },
    "id": 2
  }'
```

#### 场景2：Git操作工作流

```bash
# 1. 启动服务
mcps-proxy

# 2. 查看Git状态
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "git-status",
      "arguments": {}
    },
    "id": 3
  }'

# 3. 添加文件到暂存区
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "git-add",
      "arguments": {"files": ["."]}
    },
    "id": 4
  }'

# 4. 提交代码
curl -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "git-commit",
      "arguments": {"message": "更新文档"}
    },
    "id": 5
  }'
```

#### 场景3：多环境配置

```bash
# 1. 启动服务（所有schema同时激活）
mcps-proxy

# 2. 使用custom1 schema访问特定文件
curl -X POST http://localhost:3095/api/custom1/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "filesystem-read_file",
      "arguments": {"path": "./dev/config.json"}
    },
    "id": 6
  }'

# 3. 使用custom2 schema访问其他文件
curl -X POST http://localhost:3095/api/custom2/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "filesystem-read_file",
      "arguments": {"path": "/var/www/config.json"}
    },
    "id": 7
  }'
```

#### 场景4：脚本集成

```bash
#!/bin/bash
# file-processor.sh

# 启动mcps-proxy服务
mcps-proxy &
MCPS_PID=$!
sleep 3

# 获取文件列表
FILES=$(curl -s -X POST http://localhost:3095/api/default/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "filesystem-read_directory",
      "arguments": {"path": "./src"}
    },
    "id": 1
  }' | jq -r '.result.files[]')

# 处理每个文件
for file in $FILES; do
  echo "处理文件: $file"

  # 读取文件内容
  curl -X POST http://localhost:3095/api/default/mcp \
    -H "Content-Type: application/json" \
    -d "{
      \"jsonrpc\": \"2.0\",
      \"method\": \"tools/call\",
      \"params\": {
        \"name\": \"filesystem.read_file\",
        \"arguments\": {\"path\": \"./src/$file\"}
      },
      \"id\": 2
    }"
done

# 停止服务
kill $MCPS_PID
```

## 日志

mcps-proxy 会在后台自动记录日志，包括：
- 服务启动/停止信息
- MCP服务器连接状态
- HTTP请求和响应
- 错误信息

### 日志文件位置
- 主日志：`~/.mcps-proxy/logs/mcps-proxy.log`
- 错误日志：`~/.mcps-proxy/logs/error.log`

### 查看日志

```bash
# 查看最新的日志
tail -f ~/.mcps-proxy/logs/mcps-proxy.log

# 查看错误日志
tail -f ~/.mcps-proxy/logs/error.log
```

## 故障排除

### 常见问题

**Q: 启动失败，提示"端口已被占用"**
```bash
# 查看端口占用情况
netstat -tulpn | grep :3095

# 使用其他端口
mcps-proxy --port 8080
```

**Q: HTTP API调用失败**
```bash
# 检查服务状态
curl http://localhost:3095/api/status

# 查看错误日志
tail -f ~/.mcps-proxy/logs/error.log
```

**Q: 配置文件格式错误**
```bash
# 检查配置文件语法
cat ~/.mcps-proxy/config.json | jq empty

# 如果jq命令没有错误，说明JSON格式正确

# 重新创建默认配置
rm ~/.mcps-proxy/config.json
mcps-proxy  # 首次启动会自动创建默认配置
```

### 命令行选项

```bash
mcps-proxy [options]

选项：
  --port <port>     指定服务端口 (默认: 3095)
  --config <path>   指定配置文件路径
  --version         显示版本信息
  --help            显示帮助信息
```

**注意**: 所有schema在启动时会自动加载，无需手动选择。

## MCP服务器配置示例

### 1. HTTP类型MCP服务器
```json
{
  "zhipu-web-search": {
    "type": "http",
    "url": "https://open.bigmodel.cn/api/mcp/web_search_prime/mcp",
    "headers": {
      "Authorization": "Bearer ${Z_AI_API_KEY}"
    }
  },
  "database": {
    "type": "http",
    "url": "http://localhost:5432/mcp",
    "headers": {
      "X-API-Key": "${DB_API_KEY}",
      "Content-Type": "application/json"
    },
    "timeout": 30950
  }
}
```

### 2. stdio类型MCP服务器（使用npx）
```json
{
  "filesystem": {
    "command": "npx",
    "args": [
      "@modelcontextprotocol/server-filesystem",
      "/path/to/files"
    ]
  },
  "git": {
    "command": "npx",
    "args": [
      "@modelcontextprotocol/server-git",
      "--repository",
      "/path/to/repo"
    ]
  }
}
```

### 3. stdio类型MCP服务器（使用uvx）
```json
{
  "fetch": {
    "command": "uvx",
    "args": [
      "mcp-server-fetch"
    ]
  }
}
```

### 4. SSE类型MCP服务器
```json
{
  "sse-server": {
    "type": "sse",
    "url": "http://localhost:8080/sse",
    "headers": {
      "Authorization": "Bearer ${SSE_TOKEN}"
    }
  },
  "browser-automation": {
    "type": "sse",
    "url": "http://localhost:9222/sse",
    "reconnectInterval": 5000,
    "maxRetries": 3,
    "headers": {
      "User-Agent": "mcps-proxy/1.0.0"
    }
  }
}
```

### 5. stdio类型MCP服务器（使用Python）
```json
{
  "local-tools": {
    "command": "python",
    "args": [
      "-m",
      "custom_mcp_server"
    ],
    "env": {
      "PYTHONPATH": "/path/to/custom/modules",
      "API_KEY": "${LOCAL_API_KEY}"
    }
  }
}
```

### 配置参数说明

**通用参数：**
- `type`: 连接类型（"stdio"、"http"、"sse"），stdio类型可省略
- `name`: 服务器名称（可选，默认使用配置键名）

**HTTP类型特有参数：**
- `url`: HTTP服务器的URL地址
- `headers`: HTTP请求头（可选）
- `timeout`: 请求超时时间，单位毫秒（可选，默认10000）

**SSE类型特有参数：**
- `url`: SSE服务器的URL地址
- `headers`: SSE连接的请求头（可选）
- `reconnectInterval`: 重连间隔，单位毫秒（可选，默认1000）
- `maxRetries`: 最大重试次数（可选，默认5）

**stdio类型特有参数：**
- `command`: 启动命令
- `args`: 命令参数数组（可选）
- `env`: 环境变量对象（可选）
- `cwd`: 工作目录（可选）

## 在其他MCP客户端中使用

mcps-proxy 启动后，可以作为一个标准的MCP服务器供其他MCP客户端（如Claude Desktop、Cursor等）使用。由于mcps-proxy使用HTTP协议，需要在客户端配置中指定HTTP连接方式。

### Claude Desktop配置

在Claude Desktop的配置文件中添加以下配置：

**macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
**Windows**: `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "mcps-proxy-default": {
      "type": "http",
      "url": "http://localhost:3095/api/default/mcp"
    },
    "mcps-proxy-custom1": {
      "type": "http",
      "url": "http://localhost:3095/api/custom1/mcp"
    },
    "mcps-proxy-custom2": {
      "type": "http",
      "url": "http://localhost:3095/api/custom2/mcp"
    }
  }
}
```

### Cursor配置

在Cursor的设置中添加MCP服务器配置：

```json
{
  "mcp.servers": [
    {
      "name": "mcps-proxy-default",
      "type": "http",
      "url": "http://localhost:3095/api/default/mcp"
    },
    {
      "name": "mcps-proxy-custom1",
      "type": "http",
      "url": "http://localhost:3095/api/custom1/mcp"
    },
    {
      "name": "mcps-proxy-custom2",
      "type": "http",
      "url": "http://localhost:3095/api/custom2/mcp"
    }
  ]
}
```

### Continue.dev配置

在Continue.dev的配置文件中添加：

```json
{
  "mcpServers": [
    {
      "name": "mcps-proxy-default",
      "type": "http",
      "url": "http://localhost:3095/api/default/mcp"
    },
    {
      "name": "mcps-proxy-custom1",
      "type": "http",
      "url": "http://localhost:3095/api/custom1/mcp"
    },
    {
      "name": "mcps-proxy-custom2",
      "type": "http",
      "url": "http://localhost:3095/api/custom2/mcp"
    }
  ]
}
```

### 通用MCP客户端配置模板

对于其他支持MCP协议的客户端，可以使用以下通用配置模板：

```json
{
  "name": "mcps-proxy-{schema}",
  "type": "http",
  "url": "http://localhost:3095/api/{schema}/mcp"
}
```

**配置说明：**
- `{schema}` 替换为实际的schema名称（如 `default`、`custom1`、`custom2`）
- `port: 3095` 替换为mcps-proxy实际运行的端口
- 每个schema需要单独配置为一个MCP服务器

### 使用步骤

1. **启动mcps-proxy服务**
   ```bash
   mcps-proxy
   ```

2. **在MCP客户端中添加配置**
   - 根据客户端类型选择对应的配置模板
   - 替换 `{schema}` 为需要的schema名称（default、custom1、custom2）
   - 确保端口与mcps-proxy运行端口一致

3. **重启MCP客户端**
   - 保存配置后重启客户端以加载新的MCP服务器

4. **验证连接**
   - 在客户端中查看可用的工具列表
   - 尝试调用某个工具验证连接正常

### 注意事项

- **端口冲突**：确保mcps-proxy使用的端口与其他服务不冲突
- **网络访问**：如果客户端运行在Docker容器或远程环境中，需要确保能够访问mcps-proxy的地址和端口
- **Schema选择**：根据需要选择合适的schema（default、custom1、custom2），每个schema提供不同的工具集
- **性能考虑**：HTTP连接可能比stdio连接稍慢，但对大多数应用场景影响不大

## 最佳实践

### 1. 配置管理
- 根据实际需求修改配置文件中的MCP服务器
- 定期备份配置文件
- 使用 `jq` 工具验证JSON格式正确性

### 2. 性能优化
- 只启用需要的MCP服务器
- 合理设置服务端口
- 定期检查日志文件排查问题

### 3. 安全考虑
- 不要在配置文件中存储明文密码
- 限制代理服务的访问权限
- 定期更新依赖包

### 4. 工作流程
- 使用HTTP API进行工具调用
- 利用脚本批量处理重复性任务
- 通过curl或其他HTTP客户端与mcps-proxy交互

---

*如有问题，请使用 `mcps-proxy --help` 查看更多选项*